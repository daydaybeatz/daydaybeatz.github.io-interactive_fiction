<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zero Lux - Text Extraction Engine</title>
  <style>
    :root{
      color-scheme: dark;
      --bg:#0c0c0f;
      --panel:#121219;
      --panel-2:#191925;
      --accent:#5bd1ff;
      --accent-2:#8fffa3;
      --danger:#ff6b6b;
      --muted:#a7b0c0;
      --border:#202232;
      --shadow:0 10px 40px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    body{
      margin:0;min-height:100vh;background:radial-gradient(circle at 20% 20%, rgba(70,120,255,.08), transparent 35%),
      radial-gradient(circle at 80% 0%, rgba(80,255,200,.06), transparent 30%),
      var(--bg);
      color:#e8edf7;font-family:"Inter",system-ui,-apple-system,sans-serif;
      line-height:1.45;
      padding:12px;
    }
    #app{max-width:1200px;margin:auto;display:flex;flex-direction:column;gap:12px;}
    header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;padding:14px 16px;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);position:sticky;top:0;z-index:3;backdrop-filter:blur(6px);}
    .title{font-size:20px;font-weight:700;letter-spacing:0.5px;display:flex;align-items:center;gap:8px;}
    .tagline{font-size:13px;color:var(--muted);}
    .pill{border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,0.02);}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:14px 16px;box-shadow:var(--shadow);}
    .panel h3{margin:0 0 6px;font-size:15px;letter-spacing:0.4px;}
    .grid-two{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;}
    .statline{display:grid;grid-template-columns:110px 1fr 60px;align-items:center;font-size:13px;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03);}    
    .bar{height:8px;background:#0f111a;border-radius:999px;overflow:hidden;border:1px solid #16182a;}
    .bar span{display:block;height:100%;border-radius:999px;}
    .bar.hp span{background:linear-gradient(90deg,#ff7a7a,#ffb36b);}    
    .bar.stamina span{background:linear-gradient(90deg,#71d2ff,#82ffa4);}    
    .bar.morale span{background:linear-gradient(90deg,#8aa9ff,#c3a1ff);}    
    .bar.rads span{background:linear-gradient(90deg,#80ffd3,#fffd8a);}    
    .bar.hunger span{background:linear-gradient(90deg,#ffc46a,#ff8c8c);}    
    .bar.thirst span{background:linear-gradient(90deg,#6ad8ff,#7f9cff);}    
    .rows{display:flex;flex-direction:column;gap:8px;}
    .meta{color:var(--muted);font-size:13px;display:flex;flex-wrap:wrap;gap:10px;}
    .meta b{color:#e8edf7;margin-right:4px;}
    .pill-inline{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,0.03);font-size:12px;color:var(--muted);}    
    button{appearance:none;border:1px solid var(--border);background:var(--panel-2);color:#f6f7ff;border-radius:10px;padding:10px 12px;font-size:14px;text-align:left;cursor:pointer;transition:transform .05s ease, border .15s ease;display:flex;justify-content:space-between;align-items:center;gap:6px;min-height:46px;}
    button:hover{transform:translateY(-1px);border-color:var(--accent);}    
    button:active{transform:translateY(0);}
    .btn-secondary{background:#0f111a;}
    .danger{border-color:rgba(255,107,107,.6);color:#ffc2c2;}
    #doors,#actions{display:flex;flex-direction:column;gap:8px;}
    .log{white-space:pre-wrap;font-size:13px;color:#d8e1ff;line-height:1.35;max-height:320px;overflow:auto;padding:10px;background:#0f111a;border:1px solid var(--border);border-radius:12px;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02);}
    .small{font-size:12px;color:var(--muted);}
    .scene-title{font-size:17px;margin:0;color:#e8f1ff;}
    .scene-desc{margin:6px 0 10px;color:#cfd8ec;font-size:14px;}
    .badge{font-size:12px;border-radius:8px;padding:2px 8px;background:rgba(91,209,255,.08);border:1px solid rgba(91,209,255,.45);color:var(--accent-2);display:inline-flex;gap:6px;align-items:center;}
    .inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .inventory{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;}
    .inventory button{border:1px solid var(--border);padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.02);font-size:13px;cursor:pointer;}
    .inventory button:hover{border-color:var(--accent);}
    .inventory h4{margin:4px 0;font-size:13px;color:#cfd8ec;width:100%;}
    .inventory .pill-inline{margin-top:4px;}
    .inventory .inline-actions{width:100%;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
    .two-col{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;}
    .tabs{background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);}
    .tab-buttons{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border);flex-wrap:wrap;background:rgba(255,255,255,0.02);border-radius:12px 12px 0 0;}
    .tab-buttons button{flex:1 1 120px;text-align:center;justify-content:center;border-radius:10px;padding:10px 12px;border:1px solid var(--border);background:#0f111a;color:#e8edf7;min-height:40px;}
    .tab-buttons button.active{border-color:var(--accent);background:rgba(91,209,255,0.08);}
    .tab-buttons button:disabled{opacity:0.35;cursor:not-allowed;border-style:dashed;}
    .tab-content{display:none;padding:12px;}
    .tab-content.active{display:block;}
    .muted-box{padding:14px 16px;border-radius:10px;border:1px dashed var(--border);color:var(--muted);background:rgba(255,255,255,0.03);}
    .stack{display:flex;flex-direction:column;gap:12px;}
    .excursion-status{font-size:13px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .excursion-status b{color:#e8edf7;}
    .progress{height:10px;border-radius:999px;background:#0f111a;border:1px solid #1c1f32;overflow:hidden;}
    .progress span{display:block;height:100%;background:linear-gradient(90deg,#5bd1ff,#8fffa3);border-radius:999px;transition:width .2s ease;}
    .op-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;}
    .op-meta{display:flex;flex-wrap:wrap;gap:8px;color:var(--muted);font-size:12px;}
    .op-actions{display:flex;gap:8px;flex-wrap:wrap;}
    @media(max-width:900px){header{position:static;} .two-col{grid-template-columns:1fr;} .tab-buttons button{flex:1 1 100%;}}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <div class="title">Zero Lux Engine <span class="pill">text roguelite / extraction / survival</span></div>
        <div class="tagline">Modular expansions stitched together by a hub room. Carry stories, loot, and scars between doors.</div>
      </div>
      <div class="pill">Build #: 0.1a — mobile friendly / keyboard-free ready</div>
    </header>

    <section class="panel">
      <div class="two-col">
        <div>
          <h3>Status Board</h3>
          <div id="stats"></div>
          <div class="meta" id="meta"></div>
        </div>
        <div class="rows">
          <div class="excursion-status" id="excursionStatus"></div>
          <div class="muted-box" id="tempoHint"></div>
        </div>
      </div>
    </section>

    <div class="tabs">
      <div class="tab-buttons">
        <button data-tab="hub" class="active">Hub</button>
        <button data-tab="inventory">Inventory</button>
        <button data-tab="field">Excursion</button>
        <button data-tab="log">Signal Log</button>
      </div>
      <div id="tab-hub" class="tab-content active">
        <div class="stack">
          <section class="panel">
            <h3>Hub Doors</h3>
            <div id="doors"></div>
            <div class="small" id="doorsHint">Loading expansions…</div>
          </section>
          <section class="panel">
            <h3>Idle Operations</h3>
            <div id="idleOps"></div>
          </section>
          <div class="muted-box" id="hubLock"></div>
        </div>
      </div>
      <div id="tab-inventory" class="tab-content">
        <section class="panel">
          <h3>Inventory & Codex</h3>
          <div class="inventory" id="inventory"></div>
          <div class="small" id="codex"></div>
        </section>
      </div>
      <div id="tab-field" class="tab-content">
        <section class="panel">
          <div class="inline" style="justify-content:space-between;align-items:center;">
            <div>
              <p class="scene-title" id="sceneTitle">Hub: Signal Garage</p>
              <p class="scene-desc" id="sceneDesc">An empty staging ground. Coil cables, radio static, and chalk markings on the floor wait for doors to be bolted on.</p>
            </div>
            <span class="badge" id="sceneBadge">Idle</span>
          </div>
          <div id="actions"></div>
          <p class="small">Actions are context sensitive. Expansions can add new verbs (quests, scans, stealth crawls) and remix success/failure logic.</p>
        </section>
      </div>
      <div id="tab-log" class="tab-content">
        <section class="panel">
          <h3>Signal Log</h3>
          <div id="log" class="log"></div>
        </section>
      </div>
    </div>
  </div>

  <script>
    /* ================= STATE & CONSTANTS ================= */
    const state={
      hp:92,maxHp:100,
      stamina:100,maxStamina:100,
      morale:60,maxMorale:100,
      hunger:18,maxHunger:100,
      thirst:22,maxThirst:100,
      rads:0,heat:0,
      signal:12,maxSignal:120,
      scrap:6,
      streak:0,
      credits:50,
      day:1,dailyTasksUsed:0,timeMinutes:6*60,
      inventory:["rusty flashlight"],
      equipped:[],
      codex:["Hub online. No operations active."],
      storage:{name:'Hub Storage',items:[]},
      lootContainer:{name:'Supply Cache',items:['flare','ration bar','old coin']},
      storageMode:false,
      idleOps:{active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0},
      flags:new Set(),
      log:["Systems cold-started. Waiting for expansions…"],
      location:{expansion:null,scene:null},
      excursion:{active:false,steps:0,limit:12,startAt:null,extracting:false,reason:null,extractionDurationMs:EXTRACTION_DURATION_MS}
    };

    const lootPool=['flare','ration bar','old coin','bandage','microcell','water flask','scrap wiring','patch kit','lockbox key'];
    const TASK_MINUTES=0; // legacy placeholder
    const DAILY_TASK_LIMIT=12;
    const EXTRACTION_DURATION_MS=10000;
    const ACTION_TIMES={pulse:6,camp:12,trade:8};

    const riskTable={low:0.07,medium:0.18,high:0.3,deadly:0.45};
    const expansions={};
    const idleOperations=[
      {id:'salvage',label:'Salvage run',desc:'Remote drone gathers loose scrap and coins.',duration:7,cost:{credits:8},reward:'scrap+3,credits+4,signal+4'},
      {id:'survey',label:'Signal survey',desc:'Low-risk sweep for new signals and maps.',duration:5,cost:{credits:5},reward:'signal+8,credits+2'},
      {id:'resupply',label:'Supply errand',desc:'Courier route that brings small medical supplies.',duration:9,cost:{credits:10,scrap:1},reward:'hp+6,morale+4,item:bandage'}
    ];
    const gearTuning={
      'rusty flashlight':{riskMod:-0.02,signalBonus:1},
      'flare':{extractionSpeed:0.08},
      'patch kit':{riskMod:-0.03},
      'microcell':{idleSpeed:0.12,staminaBonus:2},
      'bandage':{healBonus:2},
      'water flask':{thirstRelief:3}
    };

    const dom={
      stats:document.getElementById('stats'),
      meta:document.getElementById('meta'),
      excursionStatus:document.getElementById('excursionStatus'),
      tempoHint:document.getElementById('tempoHint'),
      doors:document.getElementById('doors'),
      doorsHint:document.getElementById('doorsHint'),
      sceneTitle:document.getElementById('sceneTitle'),
      sceneDesc:document.getElementById('sceneDesc'),
      sceneBadge:document.getElementById('sceneBadge'),
      actions:document.getElementById('actions'),
      inventory:document.getElementById('inventory'),
      codex:document.getElementById('codex'),
      log:document.getElementById('log'),
      idleOps:document.getElementById('idleOps'),
      hubLock:document.getElementById('hubLock'),
      tabs:document.querySelector('.tabs'),
      tabButtons:Array.from(document.querySelectorAll('.tab-buttons button')),
      tabContents:{
        hub:document.getElementById('tab-hub'),
        inventory:document.getElementById('tab-inventory'),
        field:document.getElementById('tab-field'),
        log:document.getElementById('tab-log')
      }
    };

    let activeTab='hub';

    /* ================= UTILITIES ================= */
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const pct=(v,max)=>Math.round((v/max)*100);
    const fmtTime=(mins)=>{
      const m=mins%60;const h=Math.floor(mins/60)%24;const suffix=h>=12?"PM":"AM";
      const hour=((h+11)%12+1);return `${hour}:${m.toString().padStart(2,'0')} ${suffix}`;
    }
    const setCodex=(msg)=>{ state.codex=[msg]; };
    const logMsg=(msg)=>{
      const stamp=`[Day ${state.day} // ${fmtTime(state.timeMinutes)}] ${msg}`;
      state.log.unshift(stamp);
      state.log=state.log.slice(0,14);
      renderLog();
    }

    const removeItem=(arr,item)=>{const idx=arr.indexOf(item); if(idx>=0) arr.splice(idx,1);};
    const rollLoot=(count=3)=>Array.from({length:count},()=>lootPool[Math.floor(Math.random()*lootPool.length)]);
    const getGearMods=()=>{
      return state.equipped.reduce((acc,item)=>{
        const mod=gearTuning[item];
        if(!mod) return acc;
        Object.entries(mod).forEach(([key,val])=>{
          acc[key]=(acc[key]||0)+val;
        });
        return acc;
      },{});
    };
    const formatCost=(cost)=>{
      return Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(' · ');
    };
    const canAfford=(cost)=>{
      return Object.entries(cost).every(([k,v])=>state[k]>=v);
    };
    const applyCost=(cost)=>{
      Object.entries(cost).forEach(([k,v])=>{
        state[k]=Math.max(0,state[k]-v);
      });
    };
    function equipItem(item){
      if(state.equipped.includes(item)) return;
      removeItem(state.inventory,item);
      state.equipped.push(item);
      setCodex(`${item} equipped.`);
      logMsg(`Equipped ${item}.`);
      renderInventory();
    }
    function unequipItem(item){
      removeItem(state.equipped,item);
      state.inventory.push(item);
      setCodex(`${item} stowed.`);
      logMsg(`Unequipped ${item}.`);
      renderInventory();
    }
    function lootItem(item){
      removeItem(state.lootContainer.items,item);
      state.inventory.push(item);
      setCodex(`${item} recovered from ${state.lootContainer.name}.`);
      logMsg(`Looted ${item} from ${state.lootContainer.name}.`);
      renderInventory();
    }
    function depositToStorage(item){
      removeItem(state.inventory,item);
      state.storage.items.push(item);
      setCodex(`${item} stored in ${state.storage.name}.`);
      logMsg(`Stored ${item} in ${state.storage.name}.`);
      renderInventory();
    }
    function withdrawFromStorage(item){
      removeItem(state.storage.items,item);
      state.inventory.push(item);
      setCodex(`${item} withdrawn from ${state.storage.name}.`);
      logMsg(`Retrieved ${item} from ${state.storage.name}.`);
      renderInventory();
    }
    function toggleStorageMode(){
      state.storageMode=!state.storageMode;
      renderInventory();
    }
    function restockLootContainer(){
      state.lootContainer={name:'Field Locker',items:rollLoot(3)};
      setCodex('New lootable container located.');
      logMsg('A fresh lootable container is within reach.');
      renderInventory();
    }

    function startIdleOp(opId){
      if(state.idleOps.active){
        setCodex('An idle operation is already underway.');
        return;
      }
      const op=idleOperations.find(entry=>entry.id===opId);
      if(!op) return;
      if(!canAfford(op.cost)){
        setCodex('Insufficient resources for this operation.');
        return;
      }
      applyCost(op.cost);
      const gearMods=getGearMods();
      const speedMod=gearMods.idleSpeed || 0;
      const duration=Math.max(3,op.duration*(1-speedMod));
      state.idleOps={
        active:true,
        id:opId,
        startedAt:Date.now(),
        durationMs:duration*60000,
        etaMinutes:duration
      };
      logMsg(`Idle op launched: ${op.label}. ETA ${duration.toFixed(1)} mins.`);
      renderAll();
    }

    function completeIdleOp(){
      const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
      if(!op) return;
      applyEffects(op.reward,'success');
      state.idleOps={active:false,id:null,startedAt:null,durationMs:0,etaMinutes:0};
      logMsg(`Idle op complete: ${op.label}.`);
      setCodex(`Idle op returned with results: ${op.reward}.`);
      renderAll();
    }

    /* ================= RENDERING ================= */
    function renderBars(){
      const rows=[
        ['HP','hp','maxHp','hp'],
        ['Stamina','stamina','maxStamina','stamina'],
        ['Morale','morale','maxMorale','morale'],
        ['Hunger','hunger','maxHunger','hunger'],
        ['Hydration','thirst','maxThirst','thirst'],
        ['Radiation','rads',100,'rads'],
      ];
      dom.stats.innerHTML=rows.map(([label,key,maxKey,cls])=>{
        const val=state[key];const max=(typeof maxKey==='string')?state[maxKey]:maxKey;
        const percent=clamp(pct(val,max),0,200);
        return `<div class="statline"><div>${label}</div><div class="bar ${cls}"><span style="width:${percent}%;"></span></div><div>${Math.round(val)}/${max}</div></div>`;
      }).join('');
      dom.meta.innerHTML=`<span class="pill-inline"><b>Credits</b>${state.credits}</span>`+
        `<span class="pill-inline"><b>Heat</b>${state.heat}</span>`+
        `<span class="pill-inline"><b>Pressure</b>${Math.round(calcPressure()*100)}%</span>`+
        `<span class="pill-inline"><b>Signal</b>${state.signal}/${state.maxSignal}</span>`+
        `<span class="pill-inline"><b>Scrap</b>${state.scrap}</span>`+
        `<span class="pill-inline"><b>Streak</b>${state.streak}x</span>`+
        `<span class="pill-inline"><b>Tasks</b>${state.dailyTasksUsed}/${DAILY_TASK_LIMIT}</span>`+
        `<span class="pill-inline"><b>Day</b>${state.day}</span>`;
    }

    function renderInventory(){
      dom.inventory.innerHTML='';
      const buildSection=(title,items,handler,emptyText)=>{
        const wrap=document.createElement('div');
        wrap.className='inventory';
        const heading=document.createElement('h4');
        heading.textContent=title;
        wrap.appendChild(heading);
        if(!items.length){
          const span=document.createElement('span');
          span.className='small';
          span.textContent=emptyText;
          wrap.appendChild(span);
        }else{
          items.forEach(item=>{
            const btn=document.createElement('button');
            btn.textContent=item;
            btn.onclick=()=>handler(item);
            wrap.appendChild(btn);
          });
        }
        dom.inventory.appendChild(wrap);
      };

      buildSection('Equipped',state.equipped,unequipItem,'Nothing equipped. Click gear below to equip.');

      const inventoryHint=state.storageMode?`${state.storage.name} intake mode — click to store`:'Equip mode — click to ready gear';
      const inventoryHandler=state.storageMode?depositToStorage:equipItem;
      buildSection('Carried Gear',state.inventory,inventoryHandler,state.storageMode?'No carried items to store.':'No gear collected.');
      const hint=document.createElement('div');
      hint.className='inventory inline-actions';
      const toggle=document.createElement('button');
      toggle.textContent=state.storageMode?'Switch to equip mode':'Switch to storage mode';
      toggle.onclick=toggleStorageMode;
      const pill=document.createElement('span');
      pill.className='pill-inline';
      pill.textContent=inventoryHint;
      hint.appendChild(toggle);
      hint.appendChild(pill);
      dom.inventory.appendChild(hint);

      const lootEmpty=`${state.lootContainer.name} is empty.`;
      buildSection(state.lootContainer.name,state.lootContainer.items,lootItem,lootEmpty);
      const lootActions=document.createElement('div');
      lootActions.className='inventory inline-actions';
      const restockBtn=document.createElement('button');
      restockBtn.textContent='Scout new lootable container';
      restockBtn.onclick=restockLootContainer;
      lootActions.appendChild(restockBtn);
      dom.inventory.appendChild(lootActions);

      buildSection(state.storage.name,state.storage.items,withdrawFromStorage,`${state.storage.name} is empty.`);

      dom.codex.textContent = state.codex[state.codex.length-1] || '';
    }

    function renderLog(){
      dom.log.textContent=state.log.join('\n');
    }

    function renderIdleOps(){
      dom.idleOps.innerHTML='';
      const gearMods=getGearMods();
      if(state.idleOps.active){
        const op=idleOperations.find(entry=>entry.id===state.idleOps.id);
        const elapsed=Math.max(0,(Date.now()-state.idleOps.startedAt)/1000);
        const total=state.idleOps.durationMs/1000;
        const pctDone=clamp((elapsed/total)*100,0,100);
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b> · in progress`;
        const progress=document.createElement('div');
        progress.className='progress';
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const remaining=Math.max(0,Math.ceil((total-elapsed)/60));
        meta.textContent=`ETA ${remaining} min · ${op.desc}`;
        card.appendChild(title);
        card.appendChild(progress);
        card.appendChild(meta);
        dom.idleOps.appendChild(card);
        return;
      }
      idleOperations.forEach(op=>{
        const card=document.createElement('div');
        card.className='op-card';
        const title=document.createElement('div');
        title.innerHTML=`<b>${op.label}</b>`;
        const meta=document.createElement('div');
        meta.className='op-meta';
        const duration=Math.max(3,op.duration*(1-(gearMods.idleSpeed||0)));
        meta.textContent=`${op.desc} · ${duration.toFixed(1)} min`;
        const cost=document.createElement('div');
        cost.className='op-meta';
        cost.textContent=`Cost: ${formatCost(op.cost)} · Reward: ${op.reward}`;
        const actions=document.createElement('div');
        actions.className='op-actions';
        const btn=document.createElement('button');
        btn.textContent='Dispatch';
        btn.onclick=()=>startIdleOp(op.id);
        if(!canAfford(op.cost)) btn.disabled=true;
        actions.appendChild(btn);
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(cost);
        card.appendChild(actions);
        dom.idleOps.appendChild(card);
      });
    }

    function isOnExcursion(){
      return !!state.location.expansion && state.excursion.active;
    }

    function excursionSeconds(){
      if(!state.excursion.startAt) return 0;
      return Math.max(0,Math.floor((Date.now()-state.excursion.startAt)/1000));
    }

    function setActiveTab(tab){
      activeTab=tab;
      syncTabs();
    }

    function syncTabs(){
      const requested=state.excursion.active && activeTab==='hub' ? 'field' : activeTab;
      activeTab=requested;
      dom.tabButtons.forEach(btn=>{
        const target=btn.dataset.tab;
        btn.classList.toggle('active',target===activeTab);
        btn.disabled=state.excursion.active && target==='hub';
      });
      Object.entries(dom.tabContents).forEach(([id,el])=>{
        el.classList.toggle('active',id===activeTab);
      });
    }

    dom.tabButtons.forEach(btn=>{
      btn.onclick=()=>{ activeTab=btn.dataset.tab; syncTabs(); };
    });

    function renderExcursionStatus(){
      if(!state.excursion.active){
        dom.excursionStatus.innerHTML=`<b>Hub status:</b> Ready · Tasks used today ${state.dailyTasksUsed}/${DAILY_TASK_LIMIT}.`;
        dom.tempoHint.textContent='Excursions consume your 12 daily tasks. Extraction or collapse ends the run; tasks reset tomorrow.';
        return;
      }
      const remaining=Math.max(0,DAILY_TASK_LIMIT-state.dailyTasksUsed);
      const extraction=state.excursion.extracting
        ? ` · Extraction ${Math.max(0,Math.ceil((state.excursion.extractionDurationMs/1000)-excursionSeconds()))}s`
        : '';
      dom.excursionStatus.innerHTML=`<b>Excursion tempo:</b> ${state.dailyTasksUsed}/${DAILY_TASK_LIMIT} tasks used today${remaining?` · ${remaining} remaining`:' · daily allotment spent'}${extraction}`;
      const holdSeconds=Math.max(1,Math.round(state.excursion.extractionDurationMs/1000));
      dom.tempoHint.textContent=state.excursion.extracting
        ? `Extraction underway. Hold position for ${holdSeconds} seconds while the winch hauls you out.`
        : remaining? 'Each action consumes a daily task. Call extraction to bank progress before you run out.'
        : 'Daily tasks are exhausted. Extraction will haul you back automatically.';
    }

    function renderHubAccess(){
      dom.hubLock.textContent=state.excursion.active
        ? 'Hub consoles are locked while you are on excursion. Finish tasks or extract to regain access.'
        : 'Hub is open. Bolt onto a door or manage your kit before the next run.';
    }

    function appendExtractionControls(){
      if(!isOnExcursion()) return;
      const gearMods=getGearMods();
      const duration=Math.max(1,Math.round((EXTRACTION_DURATION_MS*(1-(gearMods.extractionSpeed||0)))/1000));
      const progress=document.createElement('div');
      progress.className='small';
      progress.textContent=`Tasks consumed: ${state.dailyTasksUsed}/${DAILY_TASK_LIMIT} · Extraction available`;
      const call=document.createElement('button');
      call.innerHTML=`<span>Call extraction</span><span class="small">${duration}s hold</span>`;
      call.onclick=()=>startExtraction(false,'manual');
      dom.actions.appendChild(progress);
      dom.actions.appendChild(call);
    }

    function incrementTaskUsage(){
      if(!isOnExcursion() || state.excursion.extracting) return;
      state.dailyTasksUsed=Math.min(state.dailyTasksUsed+1,DAILY_TASK_LIMIT);
      state.excursion.steps=state.dailyTasksUsed;
      renderExcursionStatus();
      if(state.dailyTasksUsed>=DAILY_TASK_LIMIT){
        logMsg('Daily task allotment exhausted. Extraction auto-triggered.');
        startExtraction(true,'day-limit');
      }
    }

    function startExtraction(autoTriggered=false,reason='manual'){
      if(!isOnExcursion() || state.excursion.extracting) return;
      const gearMods=getGearMods();
      const duration=EXTRACTION_DURATION_MS*(1-(gearMods.extractionSpeed||0));
      state.excursion.extracting=true;
      state.excursion.reason=reason;
      state.excursion.extractionDurationMs=duration;
      const seconds=Math.max(1,Math.round(duration/1000));
      logMsg(autoTriggered?`Auto-extraction initiated — daily tasks exhausted (${seconds}s).`:`Extraction requested — hold tight for ${seconds} seconds.`);
      renderAll();
      setTimeout(()=>completeExtraction(reason),duration);
    }

    function completeExtraction(reason){
      resetToHub();
      if(reason==='day-limit'){
        advanceDay();
        logMsg('Task cycle complete. A new day begins.');
      }
      logMsg('Extraction complete. Back in the hub.');
      setCodex('Hel winch hauls you home. Hub systems unlocked.');
      renderAll();
    }

    function renderScene(){
      dom.actions.innerHTML='';
      if(!state.location.expansion){
        dom.sceneBadge.textContent='Idle';
        const waiting=document.createElement('button');
        waiting.classList.add('btn-secondary');
        waiting.textContent='Awaiting expansion doors… idle scan ready';
        waiting.onclick=runPulseScan;
        dom.actions.appendChild(waiting);
        appendCoreActions();
        return;
      }
      const exp=expansions[state.location.expansion];
      const scene=exp.scenes[state.location.scene];
      dom.sceneTitle.textContent=`${exp.meta.name} — ${scene.title||scene.id}`;
      dom.sceneDesc.textContent=scene.desc||"Unmarked space.";
      dom.sceneBadge.textContent=state.excursion.extracting?'Extracting':(scene.tags?scene.tags:'Active');
      if(state.excursion.extracting){
        const hold=document.createElement('button');
        hold.textContent='Hold position…';
        hold.disabled=true;
        dom.actions.appendChild(hold);
        const progress=document.createElement('div');
        progress.className='progress';
        const duration=Math.max(1,state.excursion.extractionDurationMs/1000);
        const pctDone=clamp((excursionSeconds()/duration)*100,0,100);
        progress.innerHTML=`<span style="width:${pctDone}%;"></span>`;
        dom.actions.appendChild(progress);
        return;
      }
      if(!scene.options || !scene.options.length){
        appendExtractionControls();
        appendCoreActions();
        return;
      }
      scene.options.forEach(opt=>{
        const btn=document.createElement('button');
        const minutes=opt.time?`${opt.time} min`:'task';
        btn.innerHTML=`<span>${opt.label}</span><span class="small">${opt.risk || 'steady'} · ${minutes}</span>`;
        btn.onclick=()=>runOption(exp,scene,opt);
        if(opt.risk==='deadly') btn.classList.add('danger');
        dom.actions.appendChild(btn);
      });
      appendExtractionControls();
      appendCoreActions();
    }

    function enterScene(expansionId,sceneId){
      state.location={expansion:expansionId,scene:sceneId};
      state.excursion={active:true,steps:state.dailyTasksUsed,limit:DAILY_TASK_LIMIT,startAt:Date.now(),extracting:false,reason:null,extractionDurationMs:EXTRACTION_DURATION_MS};
      setActiveTab('field');
      renderScene();
    }

    /* ================= GAMEPLAY ================= */
    function calcPressure(){
      const hungerPressure=state.hunger>70?0.08:0;
      const thirstPressure=state.thirst>70?0.08:0;
      const fatiguePressure=state.stamina<30?0.06:0;
      const radiationPressure=state.rads*0.01;
      const heatPressure=state.heat*0.012;
      const base=0.06;
      return clamp(base+hungerPressure+thirstPressure+fatiguePressure+radiationPressure+heatPressure,0,0.85);
    }

    function computeFailChance(risk){
      const base=riskTable[risk] ?? 0.12;
      const pressure=calcPressure();
      const gearMods=getGearMods();
      const heatPenalty=Math.min(0.12,state.heat*0.002);
      const radsPenalty=Math.min(0.08,state.rads*0.004);
      const total=base + pressure*0.25 + heatPenalty + radsPenalty - (gearMods.riskMod||0);
      return clamp(total,0.05,0.75);
    }

    function tickTime(minutes){
      state.timeMinutes=(state.timeMinutes+minutes)%(24*60);
    }

    function advanceDay(){
      state.day++;
      state.dailyTasksUsed=0;
      state.excursion.steps=0;
      state.excursion.limit=DAILY_TASK_LIMIT;
      state.excursion.reason=null;
      state.timeMinutes=6*60;
    }

    function rollComplication(source){
      const pressure=calcPressure();
      if(Math.random()>pressure) return;
      const complications=[
        {desc:'A distant tracker pings your heat signature.',effects:'heat+2,morale-2'},
        {desc:'An unseen stalker snatches some scrap.',effects:'scrap-2,heat+1'},
        {desc:'Hunger cramps slow you down.',effects:'stamina-6,hp-3'},
        {desc:'Static surge fries a component.',effects:'credits-6,heat+1'},
        {desc:'Radiation spike makes your skin crawl.',effects:'rads+2,hp-4'}
      ];
      const hit=complications[Math.floor(Math.random()*complications.length)];
      applyEffects(hit.effects,'fail');
      logMsg(`Complication (${source}): ${hit.desc}`);
    }

    function applyEffects(effectStr,outcome){
      if(!effectStr) return;
      effectStr.split(',').forEach(token=>{
        token=token.trim(); if(!token) return;
        if(token.startsWith('item:')){ state.inventory.push(token.slice(5)); return; }
        if(token.startsWith('flag:')){ state.flags.add(token.slice(5)); return; }
        if(token.startsWith('note:')){ setCodex(token.slice(5)); return; }
        if(token.startsWith('log:')){ logMsg(token.slice(4)); return; }
        const match=token.match(/([a-zA-Z]+)([+-]\d+)/);
        if(match){
          const stat=match[1]; const delta=Number(match[2]);
          if(stat==='hp') state.hp=clamp(state.hp+delta,0,state.maxHp);
          else if(stat==='stamina') state.stamina=clamp(state.stamina+delta,0,state.maxStamina);
          else if(stat==='morale') state.morale=clamp(state.morale+delta,0,state.maxMorale);
          else if(stat==='hunger') state.hunger=clamp(state.hunger+delta,0,state.maxHunger);
          else if(stat==='thirst') state.thirst=clamp(state.thirst+delta,0,state.maxThirst);
          else if(stat==='rads') state.rads=Math.max(0,state.rads+delta);
          else if(stat==='heat') state.heat=Math.max(0,state.heat+delta);
          else if(stat==='credits') state.credits=Math.max(0,state.credits+delta);
          else if(stat==='scrap') state.scrap=Math.max(0,state.scrap+delta);
        }
      });
      if(outcome==='fail' && state.hp<=0){
        logMsg('You black out and are dragged back to the hub.');
        resetToHub();
        state.hp=clamp(50,1,state.maxHp);
        state.morale=clamp(state.morale-10,0,state.maxMorale);
      }
    }

    function runOption(exp,scene,opt){
      if(state.excursion.extracting) return;
      const effortMinutes=opt.time || 8;
      tickTime(effortMinutes);
      const gearMods=getGearMods();
      state.hunger=clamp(state.hunger+2,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3-(gearMods.thirstRelief||0),0,state.maxThirst);
      state.stamina=clamp(state.stamina-5+(gearMods.staminaBonus||0),0,state.maxStamina);

      const failChance=computeFailChance(opt.risk);
      const roll=Math.random();
      const success=roll>failChance;
      applyEffects(success?opt.success:opt.fail, success?'success':'fail');
      if(opt.rad) state.rads+=Number(opt.rad);
      if(opt.heat) state.heat+=Number(opt.heat);

      if(success){
        state.streak++;
        const momentumBonus=Math.min(4,Math.floor(state.streak/2));
        const signalGain=3+momentumBonus+(gearMods.signalBonus||0);
        state.signal=clamp(state.signal+signalGain,0,state.maxSignal);
        if(gearMods.healBonus){
          state.hp=clamp(state.hp+gearMods.healBonus,0,state.maxHp);
        }
        if(state.streak%3===0){
          state.scrap=clamp(state.scrap+1,0,999);
          logMsg(`Momentum ${state.streak}x — scavenged extra scrap.`);
        }
      }else{
        state.streak=0;
        state.heat=clamp(state.heat+2,0,999);
      }

      logMsg(`${success?'✓':'✖'} ${opt.label}${success?' succeeded':' failed'} (risk ${opt.risk||'steady'})`);

      rollComplication('fieldwork');

      const next=opt.target && opt.target.trim();
      if(next && success){
        enterScene(exp.meta.id,next);
      }
      incrementTaskUsage();
      renderAll();
    }

    function resetToHub(){
      state.location={expansion:null,scene:null};
      state.excursion={active:false,steps:state.dailyTasksUsed,limit:DAILY_TASK_LIMIT,startAt:null,extracting:false,reason:null,extractionDurationMs:EXTRACTION_DURATION_MS};
      dom.sceneTitle.textContent='Hub: Signal Garage';
      dom.sceneDesc.textContent='An empty staging ground. Coil cables, radio static, and chalk markings on the floor wait for doors to be bolted on.';
      dom.sceneBadge.textContent='Idle';
      dom.actions.innerHTML='';
      setActiveTab('hub');
    }

    function appendCoreActions(){
      const idle=document.createElement('button');
      idle.innerHTML=`<span>Pulse idle scan</span><span class="small">steady · ${ACTION_TIMES.pulse} min</span>`;
      idle.onclick=runPulseScan;
      const rest=document.createElement('button');
      rest.innerHTML=`<span>Make camp</span><span class="small">low · ${ACTION_TIMES.camp} min</span>`;
      rest.onclick=runCamp;
      const convert=document.createElement('button');
      convert.innerHTML=`<span>Cash in signal</span><span class="small">trade · ${ACTION_TIMES.trade} min</span>`;
      convert.onclick=burnSignal;
      dom.actions.appendChild(idle);
      dom.actions.appendChild(rest);
      dom.actions.appendChild(convert);
    }

    function runPulseScan(){
      tickTime(ACTION_TIMES.pulse);
      const gearMods=getGearMods();
      const pulse=4+Math.floor(state.streak/2)+(gearMods.signalBonus||0);
      state.signal=clamp(state.signal+pulse,0,state.maxSignal);
      state.heat=clamp(state.heat+1,0,999);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      logMsg(`Signal trickle captured (+${pulse}).`);
      incrementTaskUsage();
      renderAll();
    }

    function runCamp(){
      tickTime(ACTION_TIMES.camp);
      const gearMods=getGearMods();
      state.stamina=clamp(state.stamina+12,0,state.maxStamina);
      state.hp=clamp(state.hp+4,0,state.maxHp);
      state.morale=clamp(state.morale+2,0,state.maxMorale);
      state.hunger=clamp(state.hunger+3,0,state.maxHunger);
      state.thirst=clamp(state.thirst+3-(gearMods.thirstRelief||0),0,state.maxThirst);
      state.heat=Math.max(0,state.heat-3);
      state.streak=0;
      logMsg('You bunker down, patch gear, and reset momentum.');
      rollComplication('camp');
      incrementTaskUsage();
      renderAll();
    }

    function burnSignal(){
      if(state.signal<10){
        logMsg('Not enough signal to trade.');
        return;
      }
      tickTime(ACTION_TIMES.trade);
      const payout=4+Math.floor(state.signal/12)+Math.floor(state.streak/3);
      state.signal=Math.max(0,state.signal-10);
      state.credits+=payout;
      state.scrap=clamp(state.scrap+1,0,999);
      logMsg(`Signal monetized for ${payout} credits and salvage.`);
      incrementTaskUsage();
      renderAll();
    }

    /* ================= EXPANSION LOADING ================= */
    async function loadGames(){
      try{
        const res=await fetch('games.json');
        const data=await res.json();
        dom.doorsHint.textContent='';
        data.expansions.forEach(meta=>loadExpansion(meta));
      }catch(err){
        dom.doorsHint.textContent='Unable to load games.json';
        console.error(err);
      }
    }

    async function loadExpansion(meta){
      try{
        const res=await fetch(meta.file);
        const raw=await res.text();
        const expansion=parseExpansion(raw);
        expansion.meta.id=meta.id || expansion.meta.id;
        expansion.meta.name=meta.name || expansion.meta.name || meta.id;
        expansions[expansion.meta.id]=expansion;
        addDoor(expansion);
        logMsg(`Door bolted on: ${expansion.meta.name}`);
      }catch(err){
        logMsg(`Failed to load ${meta.id}`);
        console.error(err);
      }
    }

    function addDoor(exp){
      const btn=document.createElement('button');
      btn.innerHTML=`<span>${exp.door?.label||exp.meta.name}</span><span class="small">${exp.door?.hint||'Unknown signal'}</span>`;
      btn.onclick=()=>{
        if(state.excursion.active){
          setCodex('Hub sealed during excursion. Extract before choosing another door.');
          return;
        }
        const start=exp.door?.target||Object.keys(exp.scenes)[0];
        enterScene(exp.meta.id,start);
        if(exp.door?.note) setCodex(exp.door.note);
        renderInventory();
      };
      dom.doors.appendChild(btn);
    }

    function parseOption(str){
      // Format: Label => target | risk:low | time:10 | success:hp+5,credits+10 | fail:hp-5 | rad:1 | heat:1
      const segments=str.split('|').map(s=>s.trim()).filter(Boolean);
      const [labelPart,...rest]=segments;
      const [label,target]=labelPart.split('=>').map(s=>s&&s.trim());
      const opt={label:label||'Action',target:target||null,risk:'low',time:8,success:'',fail:'',rad:0,heat:0};
      rest.forEach(seg=>{
        const [k,vRaw]=seg.split(':');
        const v=vRaw?.trim();
        if(!k) return;
        const key=k.trim().toLowerCase();
        if(key==='risk') opt.risk=v;
        else if(key==='time') opt.time=Number(v||8);
        else if(key==='success') opt.success=v;
        else if(key==='fail') opt.fail=v;
        else if(key==='rad') opt.rad=Number(v||0);
        else if(key==='heat') opt.heat=Number(v||0);
      });
      return opt;
    }

    function parseExpansion(raw){
      const exp={meta:{},door:{},scenes:{}};
      let scope='meta';
      let currentScene=null;
      raw.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith('#')) return;
        if(line.startsWith('@expansion')){scope='meta';currentScene=null;return;}
        if(line.startsWith('@door')){scope='door';currentScene=null;return;}
        if(line.startsWith('@scene')){
          scope='scene';
          const id=line.split(/\s+/)[1] || `scene-${Object.keys(exp.scenes).length+1}`;
          currentScene={id,title:'',desc:'',tags:'',options:[]};
          exp.scenes[id]=currentScene;return;
        }
        const [key,...rest]=line.split(':');
        const value=rest.join(':').trim();
        if(scope==='meta') exp.meta[key]=value;
        else if(scope==='door') exp.door[key]=value;
        else if(scope==='scene' && currentScene){
          if(key==='option') currentScene.options.push(parseOption(value));
          else if(key==='desc') currentScene.desc += (currentScene.desc?' ':'') + value;
          else currentScene[key]=value;
        }
      });
      return exp;
    }

    function renderAll(){
      renderBars();
      renderInventory();
      renderScene();
      renderLog();
      renderExcursionStatus();
      renderHubAccess();
      renderIdleOps();
      syncTabs();
    }

    /* ================= INIT ================= */
    renderAll();
    loadGames();

    function ambientTick(){
      tickTime(4);
      if(state.idleOps.active){
        const elapsed=Date.now()-state.idleOps.startedAt;
        if(elapsed>=state.idleOps.durationMs){
          completeIdleOp();
          return;
        }
      }
      const drip=1+Math.floor(state.streak/4);
      state.signal=clamp(state.signal+drip,0,state.maxSignal);
      state.hunger=clamp(state.hunger+1,0,state.maxHunger);
      state.thirst=clamp(state.thirst+1,0,state.maxThirst);
      if(state.hunger>=90){
        applyEffects('hp-3,morale-2','fail');
        logMsg('Starvation gnaws at you while you hesitate.');
      }
      if(state.thirst>=90){
        applyEffects('hp-4,stamina-5','fail');
        logMsg('Dehydration blurs your vision.');
      }
      rollComplication('idle time');
      if(state.timeMinutes%60===0){
        logMsg('The hub crackles. Passive signal trickles in.');
      }
      renderAll();
    }

    setInterval(ambientTick,6500);
  </script>
</body>
</html>
